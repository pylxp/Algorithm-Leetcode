package java.t1_t99.t90_t99;

public class T96 {
    class Solution {
        public int numTrees(int n) {
            //这题是95的简化，建议放在一起做
            //由题意可知，这题跟95的区别只有一个
            //95需要输出树的结构，96只需要输出树的个数即可
            //采用95题的思路，分别以1~n为根节点，不难得出以下结论
            //假设以i作为根节点
            //左子树则由1~i-1构成，右子树则为i+1~n构成
            //那么单独看左子树或者右子树，实际上也是个二叉搜索树，即问题变成了
            //以i为根的n的二叉搜索树量等于左子树i~i-1和右子树i+1~n的乘积
            //f(i,n)表示以i为根的n的二叉搜索树，g(1,i~1)表示1~i-1组成的二叉搜索树数量
            //f(i,n)=Σ{i=1~n} g(1,i-1)*g(i+1,n)
            //即g(1,n)=Σ{i=1~n} g(1,i-1)*g(i+1,n)
            //单独以个数进行简化，即g(n)=Σ{i=1~n}g(i-1)*g(n-i);
            //注意n=0时，也算一种结果，即g(0)=g(1)=1,g(2)=g(0)*g(1)+g(1)*g(0)=2
            //g(3)=g(0)*g(2)+g(1)*g(1)+g(2)*g(0)=5
            //正式面试中，完整到这一步即可，下面不做要求

            //这样的数列称为卡塔兰数
            //实际上，清代数学家明安图(1692年－1763年)在其《割圜密率捷法》最早用到“卡塔兰数”
            //想更多了解可以自行谷歌或百度，
            //h(n)= h(0)*h(n-1) + h(1)*h(n-2) + ... + h(n-1)h(0) (n>=2)
            //即h(n)=C(2n,n)/(n+1)=P(2n,n)/(n+1)!=(2n)!/(n!*(n+1)!) (n=1,2,3,...)
            //那么h(n+1)/h(n)=
            //      {(2(n+1)!)/((n+1)!*(n+2)!)} / {(2n)!/(n!*(n+1)!)}=2(2n+1)/n+2
            //根据以上结论开始编写代码
            //初始化C0=1,要用long型，或者会溢出
            long C = 1;
            for (int i = 0; i < n; i++)
                C = C * 2 * (2 * i + 1) / (i + 2);
            //记得转换类型
            return (int) C;
        }
    }
}
