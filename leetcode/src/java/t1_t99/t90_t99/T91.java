package java.t1_t99.t90_t99;

public class T91 {
    class Solution {
        public int numDecodings(String s) {
            //A~Z==1~26
            //那么其实不难发现，没多添加一个数，产生的变化只有以下几种情况
            // [1]=>1=>A
            //1.添加的数字不影响原解码，直接在后面添加
            // 即[1,2]=>1,2=>AB  [1,2,3]=>1,2,3/12,3=>ABC/LC
            //2.添加的数影响原解码，即和前一位结合
            // 即[1,2]=>12=>L  [1,2,3]=>1,23=>ABLW
            // 情况1存在的特例
            // 1.即新添加的数为0时，必须于前一位结合解码
            // 情况2存在的特例
            // 1.即前一位等于2，后一位必须小于等于6
            // 2.前一位大于2，后一位必须单独解码
            //由以上结论不难看出，每次的解码结果，都是根据上一次进行的演化
            //即如果满足情况1和2，dp[n]=dp[n-1]+dp[n-2]
            //只满足情况1 ,dp[n]=dp[n-1]
            //只满足情况2 ,dp[n]=dp[n-2]
            //所以这里使用动态规划比较合适


            //转换为字符数组，便于遍历
            char[] ch = s.toCharArray();
            //创建dp动态规划数组
            int[] dp = new int[s.length() + 1];
            dp[0] = 1;
            //初始化dp数组
            dp[1] = ch[0] == '0' ? 0 : 1;
            //只有一个数，直接返回结果，非0即1
            if (s.length() <= 1) return dp[1];
            //遍历字符数组
            //为了防止f(n)=f(n-1)+f(n-2)越界，这里i表示遍历第i-1位
            //所以这里不是<s.length(),而是<=
            for (int i = 2; i <= s.length(); i++) {
                //先计算跟前一位合并的数值
                int num = (ch[i - 2] - '0') * 10 + (ch[i - 1] - '0');
                //非法情况，1.连续两个0 2.0前面大于2，则返回0
                if (ch[i - 1] == '0' && (ch[i - 2] == '0' || ch[i - 2] - '0' > 2)) return 0;
                    //如果前一位等于0，只能单独解码，dp[i] = dp[i - 1]
                else if (ch[i - 2] == '0') dp[i] = dp[i - 1];
                    //结果n超出26，即只能单独解码，dp[i] = dp[i - 1]
                else if (num > 26) dp[i] = dp[i - 1];
                    //当前位为0，只能跟前一位结合解码，即dp[i]=dp[i-2]
                else if (ch[i - 1] == '0') dp[i] = dp[i - 2];
                    //到这里则表示可以拼接前一位，也可以单独解码，即dp[i]=dp[i-1]+dp[i-2]
                else dp[i] = dp[i - 1] + dp[i - 2];
            }
            //返回结果
            return dp[s.length()];
        }
    }
}
