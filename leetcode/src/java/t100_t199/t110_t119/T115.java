package java.t100_t199.t110_t119;

public class T115 {
    class Solution {
        public int numDistinct(String s, String t) {
            //判断字符串s中字符串t出现的次数
            //那么实际上就是一个字符串匹配问题
            //区别在于
            //1.这题求得是可以匹配的次数
            //2.同个字符出现多次时，可以多次匹配
            //从这不难看出，匹配的结果数收到原先结果的影响
            //即这里可以采用dp动态规划的方法
            //创建dp矩阵 dp[i][j]表示 s的前(0~i-1)i个字符有几种方式匹配t的前j(0~j-1)个字符
            //初始化dp[i][0]=1,即t为空字符串时，结果都为1
            //那么当s[i-1]==t[j-1]时，有两种匹配情况
            //1.s[i-1]用得上，刚好匹配t[j-1],即继承原先结果dp[i-1][j-1]
            //2.s[i-1]用不上，没有s[i-1]，也能匹配跟前面匹配，即多出dp[i-1][j]
            //所以当s[i-1]==t[j-1]时，dp[i][j]= dp[i-1][j-1]+dp[i-1][j]
            //当s[i-1]!=t[j-1]时，等同于匹配得情况2,s[i-1]用不上，即dp[i][j]= dp[i-1][j]
            //到这里就好了，下面是拓展
            //上面可知，dp[i][j]得结果只受dp[i-1][j-1]和dp[i-1][j]的影响
            //而内循环的上一层结果即为dp[i-1][j]，而dp[i-1][j]外循环的上一层结果为dp[i-1][j-1]
            //因此，将s作为主序，即dp[i][j]可以简化为dp[j],表示t得前j个字符在s中有多少种匹配方式
            //即外循环在没被内循环更新前，保留在dp[j]的是dp[i][j]，更新后，dp[j]=dp[i-1][j]
            //因此为了加上dp[j-1]=dp[i-1][j-1],内存循环要采用逆序。防止dp[j-1]=dp[i-1][j-1]被其他值更新

            //创建dp数组
            int[] dp = new int[t.length() + 1];
            //初始化dp[0],即t为空，结果为1
            dp[0] = 1;
            //遍历s字符串
            for (int i = 0; i < s.length(); i++)
                //逆序遍历t字符串
                for (int j = t.length(); j > 0; j--)
                    //加上dp[j-1]=dp[i-1][j]
                    if (s.charAt(i) == t.charAt(j - 1)) dp[j] += dp[j - 1];
            //返回结果
            return dp[t.length()];
        }
    }
}
